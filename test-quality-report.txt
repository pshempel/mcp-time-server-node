=== TEST ASSERTION ANALYSIS REPORT ===

Total Tests Analyzed: 1138
Fake Tests (No Assertions): 0
Suspicious Tests: 615
Tests with Only Trivial Assertions: 466

⚠️  TESTS WITH ONLY TRIVIAL ASSERTIONS:
  tests/index.test.ts:41 - "should create server with correct info"
    Line 42: expect(server).toBeDefined();
  tests/index.test.ts:46 - "should register tool handlers"
    Line 57: expect(true).toBe(true);
  tests/index.test.ts:223 - "should return correct tool names"
    Line 233: expect(toolNames).toEqual([
  tests/index.test.ts:560 - "should read configuration from environment variables"
    Line 565: expect(process.env.CACHE_SIZE).toBe('5000');
    Line 566: expect(process.env.RATE_LIMIT).toBe('50');
  tests/index.rateLimit.test.ts:250 - "should create rate limiter with environment configuration"
    Line 260: expect(MockedRateLimiter).toHaveBeenCalled();
  tests/utils/withDebug.test.ts:33 - "logs function entry with arguments"
    Line 40: expect(debugSpy).toHaveBeenCalledWith('→ testFunction called with:', ['hello', 42]);
  tests/utils/withDebug.test.ts:43 - "logs successful completion"
    Line 50: expect(debugSpy).toHaveBeenCalledWith('✓ testFunction succeeded');
  tests/utils/withDebug.test.ts:65 - "handles async functions that succeed"
    Line 73: expect(result).toBe('async result');
    Line 74: expect(debugSpy).toHaveBeenCalledWith('→ testAsync called with:', [1]);
    Line 75: expect(debugSpy).toHaveBeenCalledWith('✓ testAsync succeeded');
  tests/utils/withDebug.test.ts:109 - "handles functions with no name"
    Line 114: expect(debugSpy).toHaveBeenCalledWith('→ anonymous called with:', [5]);
  tests/utils/withDebug.test.ts:117 - "handles error that is a Promise (edge case)"
    Line 129: expect(result).toBe(promiseError);
    Line 135: expect(debugSpy).toHaveBeenCalledWith('→ throwPromise called with:', []);
    Line 136: expect(debugSpy).not.toHaveBeenCalledWith(
  tests/utils/withDebug.test.ts:180 - "withDebugUtils uses utils namespace"
    Line 189: expect(utilsSpy).toHaveBeenCalledWith('→ utilFunction called with:', []);
    Line 190: expect(utilsSpy).toHaveBeenCalledWith('✓ utilFunction succeeded');
  tests/utils/withDebug.test.ts:195 - "withDebugCache uses cache namespace"
    Line 204: expect(cacheSpy).toHaveBeenCalledWith('→ cacheFunction called with:', []);
    Line 205: expect(cacheSpy).toHaveBeenCalledWith('✓ cacheFunction succeeded');
  tests/utils/withDebug.test.ts:210 - "supports different namespaces"
    Line 224: expect(businessSpy).toHaveBeenCalledWith('→ businessOp called with:', []);
    Line 235: expect(errorSpy).toHaveBeenCalledWith('→ errorOp called with:', []);
    Line 246: expect(parseSpy).toHaveBeenCalledWith('→ parseOp called with:', []);
  tests/utils/withCache.test.ts:42 - "should handle falsy cached values correctly"
    Line 54: expect(result).toBe(value);
    Line 55: expect(compute).not.toHaveBeenCalled();
  tests/utils/withCache.test.ts:75 - "should only compute once even if called multiple times synchronously"
    Line 91: expect(compute).toHaveBeenCalledTimes(1);
    Line 92: expect(result1).toEqual({ count: 1 });
    Line 93: expect(result2).toEqual({ count: 1 });
  tests/utils/withCache.test.ts:138 - "should handle cache.get errors gracefully"
    Line 148: expect(result).toBe('fallback');
    Line 149: expect(compute).toHaveBeenCalled();
  tests/utils/withCache.test.ts:180 - "should handle complex cache keys"
    Line 186: expect(hashCacheKey).toHaveBeenCalledWith(complexKey);
  tests/utils/withCache.test.ts:189 - "should log debug info for long cache keys when debug is enabled"
    Line 202: expect(hashCacheKey).toHaveBeenCalledWith(longKey);
  tests/utils/validation.test.ts:134 - "should create error with all fields"
    Line 141: expect(error).toEqual({
  tests/utils/validation.test.ts:148 - "should create error without details"
    Line 151: expect(error).toEqual({
  tests/utils/serverConfig.test.ts:30 - "should increase process maxListeners to 20"
    Line 36: expect(process.getMaxListeners()).toBe(20);
  tests/utils/serverConfig.test.ts:41 - "should return current configuration"
    Line 47: expect(config).toEqual({
  tests/utils/serverConfig.test.ts:55 - "should not emit warning with configured limits"
    Line 81: expect(maxListenerWarnings).toHaveLength(0);
  tests/utils/resolveTimezone.test.ts:7 - "should return system timezone when undefined"
    Line 9: expect(result).toBe(systemTimezone);
  tests/utils/resolveTimezone.test.ts:12 - "should return UTC when empty string"
    Line 14: expect(result).toBe('UTC');
  tests/utils/resolveTimezone.test.ts:17 - "should return specified timezone when provided"
    Line 19: expect(result).toBe('America/New_York');
  tests/utils/resolveTimezone.test.ts:22 - "should handle various IANA timezones"
    Line 27: expect(result).toBe(tz);
  tests/utils/resolveTimezone.test.ts:33 - "should use custom default timezone"
    Line 36: expect(result).toBe(customDefault);
  tests/utils/resolveTimezone.test.ts:39 - "should handle empty string consistently regardless of default"
    Line 44: expect(result1).toBe('UTC');
    Line 45: expect(result2).toBe('UTC');
    Line 46: expect(result3).toBe('UTC');
  tests/utils/resolveTimezone.test.ts:49 - "should preserve non-empty whitespace strings"
    Line 52: expect(result).toBe('  ');
  tests/utils/resolveTimezone.test.ts:57 - "should handle null as undefined (edge case)"
    Line 60: expect(result).toBe(systemTimezone);
  tests/utils/resolveTimezone.test.ts:65 - "should follow documented timezone handling rules"
    Line 79: expect(result).toBe(expected);
  tests/utils/rateLimit.test.ts:15 - "should create rate limiter with default values"
    Line 17: expect(rateLimiter).toBeDefined();
  tests/utils/rateLimit.test.ts:21 - "should create rate limiter with custom values"
    Line 23: expect(rateLimiter).toBeDefined();
  tests/utils/rateLimit.test.ts:57 - "should allow requests under the limit"
    Line 58: expect(rateLimiter.checkLimit()).toBe(true);
    Line 59: expect(rateLimiter.checkLimit()).toBe(true);
    Line 60: expect(rateLimiter.checkLimit()).toBe(true);
    Line 61: expect(rateLimiter.checkLimit()).toBe(true);
    Line 62: expect(rateLimiter.checkLimit()).toBe(true);
  tests/utils/rateLimit.test.ts:65 - "should deny requests over the limit"
    Line 68: expect(rateLimiter.checkLimit()).toBe(true);
    Line 72: expect(rateLimiter.checkLimit()).toBe(false);
  tests/utils/rateLimit.test.ts:75 - "should allow requests after window expires"
    Line 82: expect(rateLimiter.checkLimit()).toBe(false);
    Line 88: expect(rateLimiter.checkLimit()).toBe(true);
  tests/utils/rateLimit.test.ts:91 - "should use sliding window algorithm"
    Line 105: expect(rateLimiter.checkLimit()).toBe(false);
    Line 112: expect(rateLimiter.checkLimit()).toBe(true);
    Line 113: expect(rateLimiter.checkLimit()).toBe(true);
    Line 114: expect(rateLimiter.checkLimit()).toBe(true);
    Line 117: expect(rateLimiter.checkLimit()).toBe(false);
  tests/utils/rateLimit.test.ts:127 - "should return current usage count"
    Line 128: expect(rateLimiter.getCurrentUsage()).toBe(0);
    Line 131: expect(rateLimiter.getCurrentUsage()).toBe(1);
    Line 135: expect(rateLimiter.getCurrentUsage()).toBe(3);
  tests/utils/rateLimit.test.ts:138 - "should exclude expired requests from count"
    Line 141: expect(rateLimiter.getCurrentUsage()).toBe(2);
    Line 146: expect(rateLimiter.getCurrentUsage()).toBe(0);
  tests/utils/rateLimit.test.ts:156 - "should return 0 when under limit"
    Line 158: expect(rateLimiter.getRetryAfter()).toBe(0);
  tests/utils/rateLimit.test.ts:161 - "should return time until oldest request expires"
    Line 170: expect(rateLimiter.checkLimit()).toBe(false);
    Line 174: expect(rateLimiter.getRetryAfter()).toBe(7);
  tests/utils/rateLimit.test.ts:177 - "should handle edge case of no requests"
    Line 178: expect(rateLimiter.getRetryAfter()).toBe(0);
  tests/utils/rateLimit.test.ts:187 - "should clear all request history"
    Line 192: expect(rateLimiter.getCurrentUsage()).toBe(3);
    Line 196: expect(rateLimiter.getCurrentUsage()).toBe(0);
    Line 197: expect(rateLimiter.checkLimit()).toBe(true);
  tests/utils/rateLimit.test.ts:202 - "should clean up old timestamps automatically"
    Line 211: expect(rateLimiter.getCurrentUsage()).toBe(100);
    Line 220: expect(rateLimiter.getCurrentUsage()).toBe(1);
  tests/utils/rateLimit.test.ts:230 - "should return rate limiter information"
    Line 237: expect(info).toEqual({
  tests/utils/rateLimit.test.ts:246 - "should show retry after when at limit"
    Line 254: expect(info).toEqual({
  tests/utils/rateLimit.debug.test.ts:28 - "should log rate limiter creation when debug is enabled"
    Line 39: expect(output).toContain('mcp:rate-limit');
    Line 40: expect(output).toContain('Creating rate limiter');
    Line 41: expect(output).toContain('limit: 5');
    Line 42: expect(output).toContain('window: 10000ms');
  tests/utils/rateLimit.debug.test.ts:45 - "should log when requests are allowed"
    Line 53: expect(output).toContain('Request allowed');
    Line 54: expect(output).toContain('usage: 1/2');
  tests/utils/rateLimit.debug.test.ts:57 - "should log when rate limit is exceeded"
    Line 67: expect(output).toContain('Rate limit exceeded');
    Line 68: expect(output).toContain('usage: 2/2');
    Line 69: expect(output).toContain('retry after:');
  tests/utils/rateLimit.debug.test.ts:72 - "should not log when debug is disabled"
    Line 79: expect(stderrOutput).toHaveLength(0);
  tests/utils/rateLimit.debug.test.ts:82 - "should log cleanup operations"
    Line 98: expect(output).toContain('Cleaned up');
    Line 99: expect(output).toContain('old requests');
  tests/utils/parseTimeInput.test.ts:20 - "should handle number input directly"
    Line 22: expect(result.date.toISOString()).toBe('2025-01-01T00:00:00.000Z');
  tests/utils/parseTimeInput.test.ts:81 - "should parse date-only as start of day in UTC when timezone empty"
    Line 83: expect(result.date.toISOString()).toBe('2025-01-01T00:00:00.000Z');
  tests/utils/parseTimeInput.test.ts:86 - "should parse date-only as start of day in specified timezone"
    Line 88: expect(result.date.toISOString()).toBe('2025-01-01T05:00:00.000Z'); // Midnight EST = 5am UTC
  tests/utils/parseTimeInput.test.ts:111 - "should provide descriptive error messages"
    Line 115: expect(error.error.code).toBe(TimeServerErrorCodes.INVALID_DATE_FORMAT);
    Line 116: expect(error.error.message).toContain('Invalid');
    Line 117: expect(error.error.details).toHaveProperty('input', 'invalid');
  tests/utils/parseTimeInput.test.ts:128 - "should treat "
    Line 131: expect(result1.date.toISOString()).toBe(result2.date.toISOString());
  tests/utils/parseTimeInput.test.ts:141 - "should handle leap year dates"
    Line 143: expect(result.date.toISOString()).toBe('2024-02-29T12:00:00.000Z');
  tests/utils/parseTimeInput.test.ts:146 - "should handle very large Unix timestamps"
    Line 149: expect(result.date.getFullYear()).toBeGreaterThan(2200);
  tests/utils/parseTimeInput.test.ts:161 - "should match existing addTime.ts behavior for Unix timestamps"
    Line 163: expect(result.date.toISOString()).toBe('2025-01-01T00:00:00.000Z');
  tests/utils/parseTimeInput.test.ts:166 - "should match existing behavior for ISO with timezone"
    Line 168: expect(result.date.toISOString()).toBe('2025-01-01T07:00:00.000Z');
  tests/utils/parseTimeInput.test.ts:171 - "should match existing behavior for local time parsing"
    Line 173: expect(result.date.toISOString()).toBe('2025-01-01T17:00:00.000Z');
  tests/utils/holidayAggregator.test.ts:256 - "should only include holidays within the specified date range"
    Line 280: expect(result.has(new Date('2025-01-01').toDateString())).toBe(true); // Calendar holiday (year 2025)
    Line 281: expect(result.has(new Date('2025-02-14').toDateString())).toBe(false); // Custom, before range
    Line 282: expect(result.has(new Date('2025-07-04').toDateString())).toBe(true); // Calendar holiday (in range)
    Line 283: expect(result.has(new Date('2025-10-31').toDateString())).toBe(false); // Custom, after range
    Line 284: expect(result.has(new Date('2025-12-25').toDateString())).toBe(true); // Calendar holiday (year 2025)
  tests/utils/debug.test.ts:39 - "should output to stderr when DEBUG env is set"
    Line 46: expect(output).toContain('mcp:server');
    Line 47: expect(output).toContain('test message');
  tests/utils/debug.test.ts:50 - "should not output when DEBUG env is not set"
    Line 56: expect(stderrOutput).toHaveLength(0);
  tests/utils/debug.test.ts:59 - "should support multiple namespaces"
    Line 68: expect(output).toContain('server message');
    Line 69: expect(output).toContain('rate limit message');
    Line 70: expect(output).not.toContain('cache message');
  tests/utils/debug.test.ts:73 - "should support wildcard namespace"
    Line 82: expect(output).toContain('server message');
    Line 83: expect(output).toContain('rate limit message');
    Line 84: expect(output).toContain('timing message');
  tests/utils/debug.test.ts:89 - "should log environment variables when debug is enabled"
    Line 98: expect(output).toContain('=== MCP Server Environment ===');
    Line 99: expect(output).toContain('RATE_LIMIT: 50');
    Line 100: expect(output).toContain('RATE_LIMIT_WINDOW: 30000');
    Line 101: expect(output).toContain('DEBUG: mcp:init');
  tests/utils/debug.test.ts:104 - "should show defaults when environment variables are not set"
    Line 113: expect(output).toContain('RATE_LIMIT: 100 (default)');
    Line 114: expect(output).toContain('RATE_LIMIT_WINDOW: 60000 (default)');
  tests/utils/debug.test.ts:117 - "should not log when debug is disabled"
    Line 123: expect(stderrOutput).toHaveLength(0);
  tests/utils/debug.test.ts:128 - "should format objects for debug output"
    Line 137: expect(output).toContain('Test object:');
    Line 138: expect(output).toContain('foo');
    Line 139: expect(output).toContain('bar');
    Line 140: expect(output).toContain('nested');
    Line 141: expect(output).toContain('42');
  tests/utils/debug.test.ts:144 - "should not output when namespace is disabled"
    Line 150: expect(stderrOutput).toHaveLength(0);
  tests/utils/debug.test.ts:155 - "should be able to debug rate limit operations"
    Line 166: expect(output).toContain('Creating rate limiter with limit=100, window=60000ms');
    Line 167: expect(output).toContain('Request allowed. Current usage: 1/100');
    Line 168: expect(output).toContain('Rate limit exceeded. Retry after: 45s');
  tests/utils/debug-namespace-isolation.test.ts:67 - "should show ONLY business logic debug when DEBUG=mcp:business"
    Line 81: expect(output).toContain('mcp:business');
    Line 82: expect(output).toContain('Business calculation happening');
    Line 85: expect(output).not.toContain('mcp:timezone');
    Line 86: expect(output).not.toContain('mcp:timing');
    Line 87: expect(output).not.toContain('mcp:cache');
  tests/utils/debug-namespace-isolation.test.ts:92 - "should show ONLY timezone debug when DEBUG=mcp:timezone"
    Line 106: expect(output).toContain('mcp:timezone');
    Line 107: expect(output).toContain('Timezone conversion happening');
    Line 110: expect(output).not.toContain('mcp:business');
    Line 111: expect(output).not.toContain('mcp:timing');
    Line 112: expect(output).not.toContain('mcp:parse');
  tests/utils/debug-namespace-isolation.test.ts:117 - "should show ONLY timing debug when DEBUG=mcp:timing"
    Line 131: expect(output).toContain('mcp:timing');
    Line 132: expect(output).toContain('Duration calculation');
    Line 135: expect(output).not.toContain('mcp:business');
    Line 136: expect(output).not.toContain('mcp:timezone');
    Line 137: expect(output).not.toContain('mcp:cache');
  tests/utils/debug-namespace-isolation.test.ts:142 - "should show ONLY parse debug when DEBUG=mcp:parse"
    Line 156: expect(output).toContain('mcp:parse');
    Line 157: expect(output).toContain('Parsing user input');
    Line 160: expect(output).not.toContain('mcp:timing');
    Line 161: expect(output).not.toContain('mcp:business');
    Line 162: expect(output).not.toContain('mcp:error');
  tests/utils/debug-namespace-isolation.test.ts:167 - "should show multiple namespaces when specified"
    Line 181: expect(output).toContain('mcp:business');
    Line 182: expect(output).toContain('Business logic');
    Line 183: expect(output).toContain('mcp:timezone');
    Line 184: expect(output).toContain('Timezone logic');
    Line 187: expect(output).not.toContain('mcp:timing');
    Line 188: expect(output).not.toContain('mcp:cache');
  tests/utils/debug-namespace-isolation.test.ts:193 - "should show ONLY trace debug when DEBUG=mcp:trace"
    Line 207: expect(output).toContain('mcp:trace');
    Line 208: expect(output).toContain('Tool execution started');
    Line 211: expect(output).not.toContain('mcp:business');
    Line 212: expect(output).not.toContain('mcp:timing');
    Line 213: expect(output).not.toContain('mcp:error');
  tests/utils/debug-namespace-isolation.test.ts:218 - "should show ONLY errors when DEBUG=mcp:error"
    Line 232: expect(output).toContain('mcp:error');
    Line 233: expect(output).toContain('Error in processing');
    Line 236: expect(output).not.toContain('mcp:business');
    Line 237: expect(output).not.toContain('mcp:timing');
    Line 238: expect(output).not.toContain('mcp:trace');
  tests/utils/debug-namespace-isolation.test.ts:243 - "should show all namespaces with DEBUG=mcp:*"
    Line 260: expect(output).toContain('mcp:business');
    Line 261: expect(output).toContain('mcp:timezone');
    Line 262: expect(output).toContain('mcp:timing');
    Line 263: expect(output).toContain('mcp:parse');
    Line 264: expect(output).toContain('mcp:cache');
    Line 265: expect(output).toContain('mcp:error');
    Line 266: expect(output).toContain('mcp:trace');
  tests/utils/debug-namespace-isolation.test.ts:269 - "should show nothing when DEBUG is not set"
    Line 282: expect(output).toBe('');
  tests/utils/debug-namespace-isolation.test.ts:287 - "should NOT have debug.tools namespace anymore"
    Line 291: expect((debug as any).tools).toBeUndefined();
  tests/utils/config.test.ts:236 - "should return a complete TimeServerConfig object"
    Line 238: expect(config).toHaveProperty('defaultTimezone');
    Line 239: expect(typeof config.defaultTimezone).toBe('string');
  tests/utils/cacheKeyBuilder.test.ts:5 - "should create a simple key with prefix only"
    Line 7: expect(key).toBe('test');
  tests/utils/cacheKeyBuilder.test.ts:10 - "should handle single values"
    Line 17: expect(key).toBe('convert:time=2025-01-01:timezone=UTC');
  tests/utils/cacheKeyBuilder.test.ts:20 - "should handle arrays by joining with commas"
    Line 28: expect(key).toBe('business:custom=:holidays=2025-01-01,2025-12-25');
  tests/utils/cacheKeyBuilder.test.ts:31 - "should handle boolean flags"
    Line 39: expect(key).toBe('calc:excludeWeekends=true:includeObserved=false:optional=false');
  tests/utils/cacheKeyBuilder.test.ts:42 - "should handle optional values that might be undefined"
    Line 51: expect(key).toBe('format:calendar=:format=:timezone=America%2FNew_York');
  tests/utils/cacheKeyBuilder.test.ts:54 - "should handle dates array in a consistent format"
    Line 58: expect(key).toBe('range:dates=2025-01-01|2025-12-31');
  tests/utils/cacheKeyBuilder.test.ts:61 - "should escape special characters in values"
    Line 68: expect(key).toBe('test:path=some%3Avalue%3Awith%3Acolons:query=a%3Db%26c%3Dd');
  tests/utils/cacheKeyBuilder.test.ts:71 - "should maintain consistent key order for same inputs"
    Line 79: expect(key1).toBe('test:a=1:b=2');
    Line 80: expect(key2).toBe('test:a=1:b=2');
    Line 81: expect(key1).toBe(key2);
  tests/utils/cacheKeyBuilder.test.ts:84 - "should handle complex business days key"
    Line 101: expect(key).toContain('business_days');
    Line 102: expect(key).toContain('dates=2025-01-01|2025-01-31');
    Line 103: expect(key).toContain('excludeWeekends=true');
    Line 104: expect(key).toContain('holidays=2025-01-01,2025-01-15');
    Line 105: expect(key).toContain('timezone=America%2FNew_York'); // URL-encoded
  tests/utils/cacheKeyBuilder.test.ts:108 - "should handle empty or null prefix gracefully"
    Line 110: expect(key1).toBe('');
    Line 115: expect(key2).toBe('test=value');
  tests/utils/cacheKeyBuilder.test.ts:118 - "should handle all option types together"
    Line 128: expect(key).toBe('complex:active=true:dates=2025-01-01:id=123:note=test:tags=a,b');
  tests/utils/cacheKeyBuilder.test.ts:131 - "should be consistent with current withCache usage patterns"
    Line 143: expect(addTimeKey).toBe('add:amount=1:time=2025-01-01:timezone=UTC:unit=day');
    Line 154: expect(durationKey).toContain('start_time=2025-01-01');
    Line 155: expect(durationKey).toContain('end_time=2025-01-02');
  tests/utils/cacheKeyBuilder.test.ts:160 - "should handle undefined options object"
    Line 162: expect(key).toBe('test');
  tests/utils/cacheKeyBuilder.test.ts:165 - "should handle very long arrays efficiently"
    Line 170: expect(key).toContain('items=item0,item1');
    Line 171: expect(key.length).toBeLessThan(2000); // Should not create excessively long keys
  tests/utils/cacheKeyBuilder.test.ts:174 - "should handle special timezone formats"
    Line 180: expect(key).toBe('tz:timezone=America%2FArgentina%2FBuenos_Aires');
  tests/utils/businessUtils.test.ts:29 - "should parse valid date strings"
    Line 31: expect(result).toBeInstanceOf(Date);
    Line 32: expect(result.toISOString()).toContain('2025-01-31');
  tests/utils/businessUtils.test.ts:35 - "should parse date with time"
    Line 37: expect(result).toBeInstanceOf(Date);
  tests/utils/businessUtils.test.ts:66 - "should preserve timezone in parsing"
    Line 70: expect(result).toBeInstanceOf(Date);
  tests/utils/businessUtils.test.ts:75 - "should parse array of valid holiday dates"
    Line 79: expect(result).toHaveLength(3);
    Line 80: expect(result[0]).toBeInstanceOf(Date);
    Line 81: expect(result[1]).toBeInstanceOf(Date);
    Line 82: expect(result[2]).toBeInstanceOf(Date);
  tests/utils/businessUtils.test.ts:85 - "should handle empty array"
    Line 87: expect(result).toEqual([]);
  tests/utils/businessUtils.test.ts:90 - "should parse dates with timezone awareness"
    Line 94: expect(result).toHaveLength(1);
    Line 95: expect(result[0]).toBeInstanceOf(Date);
  tests/utils/businessUtils.test.ts:130 - "should handle dates in different formats"
    Line 134: expect(result).toHaveLength(3);
    Line 136: expect(date).toBeInstanceOf(Date);
    Line 138: expect(date.getTime()).not.toBeNaN();
  tests/utils/businessUtils.test.ts:158 - "should handle null timezone correctly"
    Line 161: expect(result).toBeInstanceOf(Date);
  tests/utils/businessUtils.test.ts:171 - "should maintain consistency between utilities"
    Line 179: expect(singleDate.getTime()).toBe(arrayDates[0].getTime());
  tests/utils/businessHoursHelpers.test.ts:79 - "should handle single day range"
    Line 86: expect(result).toEqual(['2025-01-15']);
  tests/utils/businessHoursHelpers.test.ts:89 - "should handle timezone conversion"
    Line 97: expect(result).toEqual(['2025-01-01']); // In NY timezone
  tests/utils/businessHoursHelpers.test.ts:100 - "should handle DST transitions"
    Line 108: expect(result).toHaveLength(3);
    Line 109: expect(result).toContain('2025-03-08');
    Line 110: expect(result).toContain('2025-03-09');
    Line 111: expect(result).toContain('2025-03-10');
  tests/utils/businessHoursHelpers.test.ts:116 - "should return day info for a date"
    Line 119: expect(result).toEqual({
  tests/utils/businessHoursHelpers.test.ts:136 - "should return true for weekday with no holidays"
    Line 138: expect(result).toBe(true);
  tests/utils/businessHoursHelpers.test.ts:141 - "should return false for weekend when not including weekends"
    Line 143: expect(result).toBe(false);
  tests/utils/businessHoursHelpers.test.ts:146 - "should return true for weekend when including weekends"
    Line 148: expect(result).toBe(true);
  tests/utils/businessHoursHelpers.test.ts:151 - "should return false for holiday"
    Line 156: expect(result).toBe(false);
  tests/utils/businessHoursHelpers.test.ts:159 - "should handle holiday on weekend correctly"
    Line 162: expect(result).toBe(false); // False because it's both weekend and holiday
  tests/utils/businessHoursHelpers.test.ts:172 - "should calculate full day minutes"
    Line 187: expect(result).toBe(480); // 8 hours * 60 minutes
  tests/utils/businessHoursHelpers.test.ts:190 - "should handle partial start day"
    Line 205: expect(result).toBe(420); // 7 hours * 60 minutes
  tests/utils/businessHoursHelpers.test.ts:208 - "should handle partial end day"
    Line 223: expect(result).toBe(360); // 6 hours * 60 minutes
  tests/utils/businessHoursHelpers.test.ts:226 - "should return 0 if range starts after business hours"
    Line 241: expect(result).toBe(0);
  tests/utils/businessHoursHelpers.test.ts:244 - "should return 0 if range ends before business hours"
    Line 259: expect(result).toBe(0);
  tests/utils/businessHoursHelpers.test.ts:262 - "should handle null business hours"
    Line 277: expect(result).toBe(0);
  tests/utils/businessHoursHelpers.test.ts:282 - "should build day result with all fields"
    Line 285: expect(result).toEqual({
  tests/utils/businessHoursHelpers.test.ts:294 - "should handle weekend day"
    Line 297: expect(result).toEqual({
  tests/utils/businessHoursHelpers.test.ts:306 - "should handle holiday"
    Line 309: expect(result).toEqual({
  tests/tools/subtractTime.test.ts:447 - "should use different cache keys for different parameters"
    Line 464: expect(calls[0][0]).not.toBe(calls[1][0]); // Different cache keys
  tests/tools/subtractTime.test.ts:469 - "should always include all required fields"
    Line 479: expect(result).toHaveProperty('original');
    Line 480: expect(result).toHaveProperty('result');
    Line 481: expect(result).toHaveProperty('unix_original');
    Line 482: expect(result).toHaveProperty('unix_result');
    Line 485: expect(typeof result.original).toBe('string');
    Line 486: expect(typeof result.result).toBe('string');
    Line 487: expect(typeof result.unix_original).toBe('number');
    Line 488: expect(typeof result.unix_result).toBe('number');
  tests/tools/nextOccurrenceWrapper.test.ts:18 - "should return correct shape with next, unix, and days_until"
    Line 24: expect(result).toHaveProperty('next');
    Line 25: expect(result).toHaveProperty('unix');
    Line 26: expect(result).toHaveProperty('days_until');
    Line 27: expect(typeof result.next).toBe('string');
    Line 28: expect(typeof result.unix).toBe('number');
    Line 29: expect(typeof result.days_until).toBe('number');
  tests/tools/nextOccurrenceWrapper.test.ts:203 - "should cache results with same parameters"
    Line 212: expect(result1).toEqual(result2);
  tests/tools/nextOccurrence.test.ts:360 - "should handle pattern case-insensitively"
    Line 364: expect(() =>
  tests/tools/nextOccurrence.test.ts:429 - "should throw error for invalid day_of_week"
    Line 432: expect(() =>
  tests/tools/nextOccurrence.test.ts:440 - "should throw error for invalid day_of_month"
    Line 443: expect(() =>
    Line 450: expect(() =>
  tests/tools/nextOccurrence.test.ts:458 - "should throw error for invalid time format"
    Line 461: expect(() =>
    Line 468: expect(() =>
  tests/tools/nextOccurrence.test.ts:476 - "should throw error for invalid timezone"
    Line 479: expect(() =>
  tests/tools/nextOccurrence.test.ts:487 - "should throw error for invalid start_from date"
    Line 490: expect(() =>
  tests/tools/nextOccurrence.test.ts:532 - "should use different cache keys for different parameters"
    Line 550: expect(calls[0][0]).not.toBe(calls[1][0]);
    Line 551: expect(calls[1][0]).not.toBe(calls[2][0]);
  tests/tools/nextOccurrence.test.ts:556 - "should return all required fields"
    Line 563: expect(result).toHaveProperty('next');
    Line 564: expect(result).toHaveProperty('unix');
    Line 565: expect(result).toHaveProperty('days_until');
    Line 566: expect(typeof result.next).toBe('string');
    Line 567: expect(typeof result.unix).toBe('number');
    Line 568: expect(typeof result.days_until).toBe('number');
  tests/tools/getServerInfo.test.ts:44 - "should return object with required fields"
    Line 49: expect(info).toHaveProperty('version');
    Line 50: expect(info).toHaveProperty('revision');
    Line 51: expect(info).toHaveProperty('branch');
    Line 52: expect(info).toHaveProperty('node_version');
    Line 53: expect(info).toHaveProperty('timezone');
  tests/tools/getServerInfo.test.ts:102 - "should indicate dirty status when available"
    Line 107: expect(typeof info.dirty).toBe('boolean');
  tests/tools/getCurrentTime.test.ts:189 - "should use different cache keys for different parameters"
    Line 196: expect(calls[0][0]).not.toBe(calls[1][0]); // Different cache keys
  tests/tools/getCurrentTime.test.ts:233 - "should always include all required fields"
    Line 242: expect(result).toHaveProperty('time');
    Line 243: expect(result).toHaveProperty('timezone');
    Line 244: expect(result).toHaveProperty('offset');
    Line 245: expect(result).toHaveProperty('unix');
    Line 246: expect(result).toHaveProperty('iso');
    Line 249: expect(typeof result.time).toBe('string');
    Line 250: expect(typeof result.timezone).toBe('string');
    Line 251: expect(typeof result.offset).toBe('string');
    Line 252: expect(typeof result.unix).toBe('number');
    Line 253: expect(typeof result.iso).toBe('string');
  tests/tools/getBusinessDays.test.ts:536 - "should use different cache keys for different parameters"
    Line 557: expect(calls[0][0]).not.toBe(calls[1][0]); // Different keys
    Line 558: expect(calls[1][0]).not.toBe(calls[2][0]);
  tests/tools/getBusinessDays.test.ts:563 - "should return all required fields"
    Line 571: expect(result).toHaveProperty('total_days');
    Line 572: expect(result).toHaveProperty('business_days');
    Line 573: expect(result).toHaveProperty('weekend_days');
    Line 574: expect(result).toHaveProperty('holiday_count');
    Line 575: expect(typeof result.total_days).toBe('number');
    Line 576: expect(typeof result.business_days).toBe('number');
    Line 577: expect(typeof result.weekend_days).toBe('number');
    Line 578: expect(typeof result.holiday_count).toBe('number');
  tests/tools/getBusinessDays.test.ts:581 - "should ensure counts add up correctly"
    Line 591: expect(result.business_days + result.weekend_days + result.holiday_count).toBe(
  tests/tools/getBusinessDays.holiday.test.ts:180 - "should cache results with holiday calendar in key"
    Line 191: expect(result2).toEqual(result1);
  tests/tools/formatTime.test.ts:254 - "should handle various input time formats"
    Line 265: expect(() =>
  tests/tools/formatTime.test.ts:441 - "should use different cache keys for different parameters"
    Line 462: expect(calls[0][0]).not.toBe(calls[1][0]);
    Line 463: expect(calls[1][0]).not.toBe(calls[2][0]);
  tests/tools/formatTime.test.ts:519 - "should return all required fields"
    Line 527: expect(result).toHaveProperty('formatted');
    Line 528: expect(result).toHaveProperty('original');
    Line 529: expect(typeof result.formatted).toBe('string');
    Line 530: expect(typeof result.original).toBe('string');
  tests/tools/formatTime-refactored.test.ts:22 - "should export FORMAT_TOKENS as a frozen object"
    Line 23: expect(FORMAT_TOKENS).toBeDefined();
    Line 24: expect(typeof FORMAT_TOKENS).toBe('object');
    Line 25: expect(Object.isFrozen(FORMAT_TOKENS)).toBe(true);
  tests/tools/formatTime-refactored.test.ts:50 - "should validate format type"
    Line 51: expect(() =>
  tests/tools/formatTime-refactored.test.ts:68 - "should reject empty custom_format"
    Line 69: expect(() =>
  tests/tools/formatTime-refactored.test.ts:78 - "should validate timezone if provided"
    Line 79: expect(() =>
  tests/tools/formatTime-refactored.test.ts:116 - "should log validation with debug.validation (DECORATION)"
    Line 126: expect(true).toBe(true);
    Line 132: // expect(output).toContain('validateFormatParams');
  tests/tools/formatTime-refactored.test.ts:138 - "should parse valid ISO date"
    Line 140: expect(result).toBeInstanceOf(Date);
    Line 141: expect(result.toISOString()).toBe('2025-01-15T10:30:00.000Z');
  tests/tools/formatTime-refactored.test.ts:144 - "should parse date with timezone"
    Line 146: expect(result).toBeInstanceOf(Date);
  tests/tools/formatTime-refactored.test.ts:149 - "should fallback to native Date for overflow dates"
    Line 152: expect(result).toBeInstanceOf(Date);
  tests/tools/formatTime-refactored.test.ts:198 - "should format today"
    Line 201: expect(result).toBe('today at 2:30 PM');
  tests/tools/formatTime-refactored.test.ts:204 - "should format yesterday"
    Line 207: expect(result).toBe('yesterday at 2:30 PM');
  tests/tools/formatTime-refactored.test.ts:210 - "should format tomorrow"
    Line 213: expect(result).toBe('tomorrow at 2:30 PM');
  tests/tools/formatTime-refactored.test.ts:216 - "should format last week"
    Line 219: expect(result).toBe('last Friday at 2:30 PM');
  tests/tools/formatTime-refactored.test.ts:222 - "should format next week"
    Line 225: expect(result).toBe('Monday at 2:30 PM');
  tests/tools/formatTime-refactored.test.ts:228 - "should format dates beyond a week"
    Line 231: expect(result).toBe('02/01/2025 at 2:30 PM');
  tests/tools/formatTime-refactored.test.ts:234 - "should respect timezone"
    Line 237: expect(result).toBe('today at 3:00 PM');
  tests/tools/formatTime-refactored.test.ts:254 - "should format with valid format string"
    Line 257: expect(result).toBe('2025-01-15 14:30:00');
  tests/tools/formatTime-refactored.test.ts:278 - "should handle escaped content"
    Line 281: expect(result).toBe('Today is Wednesday');
  tests/tools/formatTime-refactored.test.ts:284 - "should respect timezone"
    Line 287: expect(result).toBe('15:00');
  tests/tools/formatTime-refactored.test.ts:330 - "should have reduced complexity"
    Line 333: expect(typeof validateFormatParams).toBe('function');
    Line 334: expect(typeof parseTimeWithFallback).toBe('function');
    Line 335: expect(typeof formatRelativeTime).toBe('function');
    Line 336: expect(typeof formatCustomTime).toBe('function');
  tests/tools/error-handling-fix.test.ts:148 - "should set error codes correctly"
    Line 157: expect(typeof error.code).toBe('string');
    Line 159: expect(['TIMEZONE_ERROR', 'VALIDATION_ERROR', 'DATE_PARSING_ERROR']).toContain(error.code);
  tests/tools/debug-coverage.test.ts:67 - "should log delegation to addTime"
    Line 81: expect(output).toContain('subtractTime called');
    Line 82: expect(output).toContain('Delegating to addTime with negated amount');
  tests/tools/debug-coverage.test.ts:85 - "should not log when DEBUG is not set"
    Line 97: expect(output).toBe('');
  tests/tools/debug-coverage.test.ts:123 - "should log format validation with validation namespace"
    Line 137: expect(output).toContain('mcp:validation');
    Line 138: expect(output).toContain('isValidFormatString');
  tests/tools/debug-coverage.test.ts:141 - "should log parsing with parse namespace"
    Line 154: expect(output).toContain('mcp:parse');
    Line 155: expect(output).toContain('parseTimeWithFallback');
  tests/tools/debug-coverage.test.ts:158 - "should log relative formatting logic"
    Line 171: expect(output).toContain('mcp:timing');
    Line 172: expect(output).toContain('formatRelativeTime');
  tests/tools/debug-coverage.test.ts:195 - "should log entry with recurrence namespace"
    Line 208: expect(output).toContain('mcp:recurrence');
    Line 209: expect(output).toContain('nextOccurrence called');
    Line 212: expect(result).toHaveProperty('next');
    Line 213: expect(result).toHaveProperty('unix');
    Line 214: expect(result).toHaveProperty('days_until');
  tests/tools/debug-coverage.test.ts:217 - "should log parameter mapping"
    Line 231: expect(output).toContain('mapToRecurrenceParams');
    Line 232: expect(output).toContain('pattern: weekly');
  tests/tools/debug-coverage.test.ts:235 - "should log calculation steps"
    Line 248: expect(output).toContain('calculateNextOccurrence');
    Line 249: expect(output).toContain('calculateDaysUntil');
  tests/tools/debug-coverage.test.ts:252 - "should log parsing with parse namespace when start_from is provided"
    Line 265: expect(output).toContain('mcp:parse');
    Line 266: expect(output).toContain('Parsing start_from');
  tests/tools/debug-coverage.test.ts:269 - "should log validation with validation namespace"
    Line 282: expect(output).toContain('mcp:validation');
    Line 283: expect(output).toContain('Validating timezone');
  tests/tools/debug-coverage.test.ts:286 - "should log return value"
    Line 298: expect(output).toContain('nextOccurrence returning');
    Line 299: expect(result).toHaveProperty('next');
  tests/tools/debug-coverage.test.ts:304 - "subtractTime should only show in timing namespace"
    Line 318: expect(output).not.toContain('subtractTime');
  tests/tools/debug-coverage.test.ts:321 - "nextOccurrence should only show in recurrence namespace"
    Line 333: expect(output).not.toContain('nextOccurrence');
  tests/tools/daysUntil.test.ts:15 - "should calculate days until a future date"
    Line 21: expect(result).toBe(7);
  tests/tools/daysUntil.test.ts:24 - "should return 0 for today"
    Line 28: expect(result).toBe(0);
  tests/tools/daysUntil.test.ts:31 - "should return negative days for past dates"
    Line 36: expect(result).toBe(-5);
  tests/tools/daysUntil.test.ts:39 - "should handle dates far in the future"
    Line 41: expect(result).toBeGreaterThan(1000); // At least 1000 days away
  tests/tools/daysUntil.test.ts:46 - "should accept ISO date format"
    Line 51: expect(result).toBe(1);
  tests/tools/daysUntil.test.ts:54 - "should accept ISO datetime format"
    Line 59: expect(result).toBe(1);
  tests/tools/daysUntil.test.ts:62 - "should handle natural language dates"
    Line 68: expect(result).toBe(1);
  tests/tools/daysUntil.test.ts:73 - "should use system timezone when not specified"
    Line 78: expect(result).toBe(1);
  tests/tools/daysUntil.test.ts:81 - "should use UTC when timezone is empty string"
    Line 89: expect(result).toBe(1);
  tests/tools/daysUntil.test.ts:92 - "should use specified timezone"
    Line 102: expect(result).toBeGreaterThan(0);
  tests/tools/daysUntil.test.ts:107 - "should return plain number by default"
    Line 112: expect(typeof result).toBe('number');
    Line 113: expect(result).toBe(1);
  tests/tools/daysUntil.test.ts:116 - "should format as "
    Line 123: expect(result).toBe('Today');
  tests/tools/daysUntil.test.ts:126 - "should format as "
    Line 134: expect(result).toBe('Tomorrow');
  tests/tools/daysUntil.test.ts:137 - "should format as "
    Line 145: expect(result).toBe('Yesterday');
  tests/tools/daysUntil.test.ts:148 - "should format as "
    Line 156: expect(result).toBe('in 10 days');
  tests/tools/daysUntil.test.ts:159 - "should format as "
    Line 167: expect(result).toBe('5 days ago');
  tests/tools/daysUntil.test.ts:172 - "should handle same day different times as 0 days"
    Line 180: expect(result).toBe(0);
  tests/tools/daysUntil.test.ts:183 - "should handle leap year dates"
    Line 186: expect(typeof result).toBe('number');
    Line 188: expect(result).toBeLessThan(0);
  tests/tools/daysUntil.test.ts:191 - "should handle year boundaries"
    Line 194: expect(result).toBeGreaterThan(0);
  tests/tools/daysUntil.test.ts:242 - "should calculate days until Christmas 2025"
    Line 249: expect(result).toBeGreaterThan(0);
    Line 250: expect(result).toBeLessThan(365);
  tests/tools/daysUntil.test.ts:253 - "should handle event planning scenario"
    Line 264: expect(result).toBe('in 30 days');
  tests/tools/daysUntil.test.ts:267 - "should handle deadline tracking"
    Line 275: expect(result).toBe(14);
  tests/tools/convertTimezone.test.ts:341 - "should use different cache keys for different parameters"
    Line 358: expect(calls[0][0]).not.toBe(calls[1][0]); // Different cache keys
  tests/tools/convertTimezone.test.ts:363 - "should always include all required fields"
    Line 373: expect(result).toHaveProperty('original');
    Line 374: expect(result).toHaveProperty('converted');
    Line 375: expect(result).toHaveProperty('from_offset');
    Line 376: expect(result).toHaveProperty('to_offset');
    Line 377: expect(result).toHaveProperty('difference');
    Line 380: expect(typeof result.original).toBe('string');
    Line 381: expect(typeof result.converted).toBe('string');
    Line 382: expect(typeof result.from_offset).toBe('string');
    Line 383: expect(typeof result.to_offset).toBe('string');
    Line 384: expect(typeof result.difference).toBe('number');
  tests/tools/convertTimezone-formatting.test.ts:7 - "should preserve explicit offset format"
    Line 14: expect(result).toBe('2021-01-01T05:00:00.000+05:00');
  tests/tools/convertTimezone-formatting.test.ts:17 - "should add milliseconds if missing with explicit offset"
    Line 20: expect(result).toBe('2021-01-01T05:00:00.000+05:00');
  tests/tools/convertTimezone-formatting.test.ts:23 - "should format time without explicit offset"
    Line 26: expect(result).toContain('2020-12-31T19:00:00');
    Line 27: expect(result).toContain('-05:00');
  tests/tools/convertTimezone-formatting.test.ts:30 - "should format UTC time"
    Line 33: expect(result).toBe('2021-01-01T00:00:00.000Z');
  tests/tools/convertTimezone-formatting.test.ts:37 - "should log formatting attempts"
    Line 39: expect(result).toBeDefined();
  tests/tools/convertTimezone-formatting.test.ts:45 - "should extract explicit offset from time string"
    Line 52: expect(result).toBe('+05:00');
  tests/tools/convertTimezone-formatting.test.ts:55 - "should return Z for Z suffix"
    Line 58: expect(result).toBe('Z');
  tests/tools/convertTimezone-formatting.test.ts:61 - "should return Z for UTC timezone"
    Line 64: expect(result).toBe('Z');
  tests/tools/convertTimezone-formatting.test.ts:67 - "should format offset for timezone"
    Line 70: expect(result).toBe('-05:00');
  tests/tools/convertTimezone-formatting.test.ts:73 - "should handle negative offsets"
    Line 80: expect(result).toBe('-08:00');
  tests/tools/convertTimezone-formatting.test.ts:84 - "should log extraction attempts"
    Line 86: expect(result).toBeDefined();
  tests/tools/calculateDuration.test.ts:305 - "should throw error for invalid start time"
    Line 308: expect(() =>
  tests/tools/calculateDuration.test.ts:316 - "should throw error for invalid end time"
    Line 319: expect(() =>
  tests/tools/calculateDuration.test.ts:327 - "should throw error for invalid timezone"
    Line 330: expect(() =>
  tests/tools/calculateDuration.test.ts:339 - "should throw error for invalid unit parameter"
    Line 342: expect(() =>
  tests/tools/calculateDuration.test.ts:389 - "should use different cache keys for different parameters"
    Line 404: expect(calls[0][0]).not.toBe(calls[1][0]); // Different cache keys
  tests/tools/calculateDuration-parsing.test.ts:5 - "should parse valid Unix timestamp string"
    Line 7: expect(result.toISOString()).toBe('2025-01-01T00:00:00.000Z');
  tests/tools/calculateDuration-parsing.test.ts:20 - "should parse ISO string with Z suffix"
    Line 22: expect(result.toISOString()).toBe('2025-01-01T12:00:00.000Z');
  tests/tools/calculateDuration-parsing.test.ts:25 - "should parse ISO string with offset"
    Line 27: expect(result.toISOString()).toBe('2025-01-01T17:00:00.000Z');
  tests/tools/calculateDuration-parsing.test.ts:30 - "should parse ISO string with positive offset"
    Line 32: expect(result.toISOString()).toBe('2025-01-01T03:00:00.000Z');
  tests/tools/calculateDuration-parsing.test.ts:37 - "should use provided timezone for local time string"
    Line 41: expect(result).toBeInstanceOf(Date);
  tests/tools/calculateDuration-parsing.test.ts:44 - "should handle date-only strings with timezone"
    Line 46: expect(result).toBeInstanceOf(Date);
  tests/tools/calculateDuration-parsing.test.ts:66 - "should log parsing attempts"
    Line 70: expect(result).toBeInstanceOf(Date);
  tests/tools/calculateDuration-calculation.test.ts:67 - "should format with auto unit"
    Line 69: expect(result).toBe('1 day 1 hour 1 minute 1 second');
  tests/tools/calculateDuration-calculation.test.ts:72 - "should format with seconds unit"
    Line 74: expect(result).toBe('90061 seconds');
  tests/tools/calculateDuration-calculation.test.ts:77 - "should format with minutes unit"
    Line 79: expect(result).toBe('1501.0166666666667 minutes');
  tests/tools/calculateDuration-calculation.test.ts:82 - "should format with hours unit"
    Line 84: expect(result).toBe('25.016944444444444 hours');
  tests/tools/calculateDuration-calculation.test.ts:87 - "should format with days unit"
    Line 89: expect(result).toBe('1.042372685185185 days');
  tests/tools/calculateDuration-calculation.test.ts:92 - "should format negative durations with auto"
    Line 95: expect(result).toBe('-1 day 1 hour 1 minute 1 second');
  tests/tools/calculateDuration-calculation.test.ts:98 - "should format zero duration"
    Line 108: expect(result).toBe('0 seconds');
  tests/tools/calculateDuration-calculation.test.ts:111 - "should format milliseconds unit"
    Line 113: expect(result).toBe('90061000 milliseconds');
  tests/tools/calculateDuration-calculation.test.ts:116 - "should handle sub-second durations with auto"
    Line 126: expect(result).toBe('0 seconds');
  tests/tools/calculateDuration-calculation.test.ts:131 - "should log calculation values"
    Line 137: expect(values).toBeDefined();
    Line 140: expect(formatted).toBeDefined();
  tests/tools/calculateBusinessHours.test.ts:392 - "should use different cache keys for different parameters"
    Line 411: expect(firstCall).not.toBe(secondCall);
  tests/tools/calculateBusinessHours.extracted.test.ts:15 - "should generate single date for same day range"
    Line 24: expect(result).toEqual(expected);
  tests/tools/calculateBusinessHours.extracted.test.ts:27 - "should generate multiple dates for multi-day range"
    Line 36: expect(result).toEqual(expected);
  tests/tools/calculateBusinessHours.extracted.test.ts:39 - "should handle timezone correctly for date boundaries"
    Line 49: expect(result).toEqual(expected);
  tests/tools/calculateBusinessHours.extracted.test.ts:52 - "should not duplicate dates"
    Line 62: expect(result).toEqual(expected);
  tests/tools/calculateBusinessHours.extracted.test.ts:218 - "should aggregate results correctly"
    Line 252: expect(result).toEqual(expected);
  tests/tools/calculateBusinessHours.extracted.test.ts:255 - "should handle empty breakdown"
    Line 266: expect(result).toEqual(expected);
  tests/tools/addTime.test.ts:434 - "should use different cache keys for different parameters"
    Line 451: expect(calls[0][0]).not.toBe(calls[1][0]); // Different cache keys
  tests/tools/addTime.test.ts:456 - "should always include all required fields"
    Line 466: expect(result).toHaveProperty('original');
    Line 467: expect(result).toHaveProperty('result');
    Line 468: expect(result).toHaveProperty('unix_original');
    Line 469: expect(result).toHaveProperty('unix_result');
    Line 472: expect(typeof result.original).toBe('string');
    Line 473: expect(typeof result.result).toBe('string');
    Line 474: expect(typeof result.unix_original).toBe('number');
    Line 475: expect(typeof result.unix_result).toBe('number');
  tests/tools/addTime-formatting.test.ts:148 - "should log formatting attempts"
    Line 168: expect(result).toBeDefined();
  tests/security/mcp-attack-vectors.test.ts:156 - "should handle extremely large date ranges"
    Line 170: expect(typeof result.business_days).toBe('number');
    Line 174: expect(error).toBeDefined();
  tests/security/mcp-attack-vectors.test.ts:221 - "should ignore constructor.prototype in parameters"
    Line 233: expect(result).toBeDefined();
    Line 234: expect((Object.prototype as any).polluted).toBeUndefined();
  tests/security/mcp-attack-vectors.test.ts:274 - "should handle negative amount overflow"
    Line 286: expect(result).toBeDefined();
    Line 289: expect(error).toBeDefined();
  tests/security/cacheKeySanitization.test.ts:32 - "should generate different hashes for different inputs"
    Line 42: expect(key1).not.toBe(key2);
    Line 43: expect(key1).toMatch(/^[a-f0-9]{64}$/);
    Line 44: expect(key2).toMatch(/^[a-f0-9]{64}$/);
  tests/security/cacheKeySanitization.test.ts:47 - "should handle filesystem-problematic characters in cache keys"
    Line 65: expect(actualKey).toMatch(/^[a-f0-9]{64}$/);
    Line 66: expect(actualKey).not.toContain('/');
    Line 67: expect(actualKey).not.toContain(':');
    Line 68: expect(actualKey).not.toContain(' ');
  tests/security/cacheKeySanitization.test.ts:72 - "should handle timezone strings with various valid characters"
    Line 92: expect(actualKey).toMatch(/^[a-f0-9]{64}$/);
    Line 94: expect(actualKey).not.toMatch(/[/_+\-A-Z]/);
  tests/security/cacheKeySanitization.test.ts:111 - "should handle all parameter combinations"
    Line 122: expect(actualKey).toMatch(/^[a-f0-9]{64}$/);
    Line 124: expect(actualKey).not.toContain('America');
    Line 125: expect(actualKey).not.toContain('false');
    Line 126: expect(actualKey).not.toContain('yyyy');
  tests/security/cacheKeySanitization.test.ts:129 - "should produce consistent hashes for the same input"
    Line 147: expect(key1).toBe(key2);
  tests/security/cacheKeySanitization.test.ts:150 - "should work correctly with cache get operations"
    Line 162: expect(setKey).toBe(getKey);
    Line 163: expect(setKey).toMatch(/^[a-f0-9]{64}$/);
    Line 164: expect(result1).toEqual(result2);
  tests/security/cacheKeySanitization.test.ts:169 - "should use the same hashing method across all tools"
    Line 186: expect(actualKey).toMatch(/^[a-f0-9]{64}$/);
  tests/security/cacheKeySanitization.test.ts:192 - "should hash keys efficiently"
    Line 205: expect(perCall).toBeLessThan(1);
  tests/performance/benchmark.test.ts:18 - "getCurrentTime - cached"
    Line 30: expect(durationMs).toBeLessThan(5); // Increased from 1ms to account for SHA-256 hashing
  tests/performance/benchmark.test.ts:33 - "getBusinessDays - cached"
    Line 50: expect(durationMs).toBeLessThan(5); // Increased from 1ms to account for SHA-256 hashing
  tests/performance/benchmark.test.ts:55 - "getCurrentTime - fresh"
    Line 61: expect(durationMs).toBeLessThan(10);
  tests/performance/benchmark.test.ts:64 - "convertTimezone - fresh"
    Line 74: expect(durationMs).toBeLessThan(10);
  tests/performance/benchmark.test.ts:77 - "calculateDuration - fresh"
    Line 87: expect(durationMs).toBeLessThan(10);
  tests/performance/benchmark.test.ts:92 - "getBusinessDays with holidays - fresh"
    Line 104: expect(durationMs).toBeLessThan(50);
  tests/performance/benchmark.test.ts:107 - "calculateBusinessHours with holidays - fresh"
    Line 119: expect(durationMs).toBeLessThan(100); // Relaxed to 100ms to account for error architecture overhead
  tests/performance/benchmark.test.ts:122 - "getBusinessDays with Easter holidays - fresh"
    Line 133: expect(durationMs).toBeLessThan(50);
  tests/performance/benchmark.test.ts:138 - "100 getCurrentTime calls should average < 1ms each"
    Line 152: expect(avgMs).toBeLessThan(5); // Increased from 1ms to account for SHA-256 hashing
  tests/meta/test-quality.test.ts:54 - "async tests should properly await their assertions"
    Line 66: if (nextLines.includes('expect(') && !nextLines.includes('await')) {
    Line 76: expect(issues).toEqual([]);
  tests/meta/test-quality.test.ts:97 - "no test should use console.log instead of assertions"
    Line 128: if (line.includes('expect(')) hasExpect = true;
    Line 135: expect(issues).toEqual([]);
  tests/meta/test-quality.test.ts:147 - "should generate a comprehensive test quality report"
    Line 152: expect(report).toContain('TEST ASSERTION ANALYSIS REPORT');
    Line 153: expect(report).toContain('Total Tests Analyzed:');
    Line 154: expect(report).toContain('RECOMMENDATIONS');
    Line 163: expect(fs.existsSync(reportPath)).toBe(true);
    Line 164: expect(fs.existsSync(path.join(process.cwd(), 'test-assertion-report.json'))).toBe(true);
  tests/integration/toolDescriptions.test.ts:10 - "should return tool descriptions with system timezone as default"
    Line 27: expect(getCurrentTimeTool).toBeDefined();
    Line 29: expect(getCurrentTimeSchema?.properties?.timezone?.description).toBe(
    Line 35: expect(addTimeTool).toBeDefined();
    Line 37: expect(addTimeSchema?.properties?.timezone?.description).toBe(
    Line 43: expect(subtractTimeTool).toBeDefined();
    Line 45: expect(subtractTimeSchema?.properties?.timezone?.description).toBe(
    Line 51: expect(calculateDurationTool).toBeDefined();
    Line 53: expect(calculateDurationSchema?.properties?.timezone?.description).toBe(
    Line 59: expect(getBusinessDaysTool).toBeDefined();
    Line 61: expect(getBusinessDaysSchema?.properties?.timezone?.description).toBe(
    Line 67: expect(nextOccurrenceTool).toBeDefined();
    Line 69: expect(nextOccurrenceSchema?.properties?.timezone?.description).toBe(
    Line 75: expect(formatTimeTool).toBeDefined();
    Line 77: expect(formatTimeSchema?.properties?.timezone?.description).toBe(
    Line 83: expect(convertTimezoneTool).toBeDefined();
    Line 85: expect(convertTimezoneSchema?.properties?.from_timezone?.description).toBe(
    Line 88: expect(convertTimezoneSchema?.properties?.to_timezone?.description).toBe(
    Line 94: expect(daysUntilTool).toBeDefined();
    Line 95: expect(daysUntilTool?.description).toBe('Calculate days until a target date/event');
    Line 97: expect(daysUntilSchema?.properties?.timezone?.description).toBe(
    Line 100: expect(daysUntilSchema?.required).toEqual(['target_date']);
  tests/integration/setup.test.ts:7 - "should create linked transport pair"
    Line 9: expect(clientTransport).toBeDefined();
    Line 10: expect(serverTransport).toBeDefined();
  tests/integration/setup.test.ts:15 - "should connect client and server"
    Line 18: expect(client).toBeDefined();
    Line 19: expect(server).toBeDefined();
  tests/integration/setup.test.ts:42 - "should create environment with custom rate limits"
    Line 52: expect(process.env.RATE_LIMIT).toBe('10');
    Line 53: expect(process.env.RATE_LIMIT_WINDOW).toBe('5000');
    Line 58: expect(process.env.RATE_LIMIT).toBe(originalRateLimit);
    Line 59: expect(process.env.RATE_LIMIT_WINDOW).toBe(originalWindow);
  tests/integration/mcp-external-validation.test.ts:74 - "should calculate business days correctly for known date ranges"
    Line 81: expect(result.result.content[0].text).toContain('"business_days":23');
  tests/integration/mcp-external-validation.test.ts:84 - "should calculate business hours matching real-world expectations"
    Line 91: expect(result.result.content[0].text).toContain('"total_business_hours":40');
  tests/integration/mcp-external-validation.test.ts:94 - "should handle timezone conversions matching external sources"
    Line 102: expect(result.result.content[0].text).toContain('07:00:00');
  tests/integration/mcp-external-validation.test.ts:105 - "should calculate duration matching manual calculation"
    Line 113: expect(result.result.content[0].text).toContain('336');
  tests/integration/mcp-external-validation.test.ts:118 - "should handle DST transitions correctly"
    Line 128: expect(result.result.content[0].text).toContain('23');
  tests/integration/mcp-external-validation.test.ts:131 - "should exclude US holidays from business days"
    Line 140: expect(result.result.content[0].text).toContain('"business_days":22');
  tests/integration/mcp-external-validation.test.ts:145 - "should show same moment in different timezones correctly"
    Line 162: expect(nyResult.result.content[0].text).toContain('11:00:00');
    Line 165: expect(tokyoResult.result.content[0].text).toContain('2025-06-16');
    Line 166: expect(tokyoResult.result.content[0].text).toContain('00:00:00');
  tests/integration/maxListeners.test.ts:12 - "should handle many concurrent requests without MaxListenersExceededWarning"
    Line 38: expect(maxListenerWarnings).toHaveLength(0);
  tests/integration/maxListeners.test.ts:48 - "should handle rapid sequential requests without warnings"
    Line 68: expect(maxListenerWarnings).toHaveLength(0);
  tests/integration/error-handling-chain.test.ts:130 - "should map errors in business hours calculation"
    Line 140: expect('error' in result).toBe(true);
    Line 144: expect(result.error.code).toBeDefined();
    Line 145: expect(result.error.message).toBeDefined();
  tests/integration/error-handling-chain.test.ts:151 - "should preserve error details through the chain"
    Line 156: expect('error' in result).toBe(true);
    Line 158: expect(result.error.data).toBeDefined();
    Line 159: expect(result.error.data).toHaveProperty('timezone', 'Fake/Zone');
  tests/integration/error-handling-chain.test.ts:177 - "should handle circular references in error objects"
    Line 185: expect('error' in result).toBe(true);
    Line 187: expect(result.error.code).toBeDefined();
    Line 188: expect(result.error.message).toBeDefined();
  tests/integration/error-handling-chain.test.ts:216 - "should still return successful results normally"
    Line 219: expect('error' in result).toBe(false);
    Line 221: expect(result).toHaveProperty('content');
    Line 223: expect(parsed).toHaveProperty('version');
    Line 224: expect(parsed).toHaveProperty('branch');
    Line 225: expect(parsed).toHaveProperty('timezone');
  tests/integration/advanced.test.ts:6 - "should handle concurrent requests"
    Line 18: expect(results[0]).toHaveProperty('timezone', 'UTC');
    Line 19: expect(results[1]).toHaveProperty('result');
    Line 20: expect(results[2]).toHaveProperty('formatted');
  tests/integration/advanced.test.ts:53 - "should handle concurrent requests with different tools"
    Line 83: expect(results[0]).toHaveProperty('timezone');
    Line 84: expect(results[1]).toHaveProperty('converted');
    Line 85: expect(results[2]).toHaveProperty('result');
    Line 86: expect(results[3]).toHaveProperty('hours', 24);
    Line 87: expect(results[4]).toHaveProperty('business_days');
  tests/integration/advanced.test.ts:93 - "should handle concurrent requests with errors"
    Line 108: expect(results[0]).toHaveProperty('timezone');
    Line 111: expect(results[1]).toBeInstanceOf(Error);
    Line 112: expect(results[1]).toHaveProperty('code', 'TOOL_ERROR');
    Line 115: expect(results[2]).toHaveProperty('formatted');
  tests/integration/advanced.test.ts:123 - "should maintain message order"
    Line 134: expect(requests[0].params.name).toBe('get_current_time');
    Line 135: expect(requests[1].params.name).toBe('add_time');
  tests/integration/advanced.test.ts:172 - "should match request and response IDs"
    Line 186: expect(request).toBeDefined();
    Line 187: expect(response).toBeDefined();
    Line 188: expect(response?.id).toBe(request?.id);
  tests/integration/advanced.test.ts:194 - "should handle interleaved concurrent requests correctly"
    Line 207: expect(results[0].timezone).toBe('UTC');
    Line 208: expect(results[1].timezone).toBe('America/New_York');
    Line 209: expect(results[2].timezone).toBe('Asia/Tokyo');
    Line 214: expect(new Set(ids).size).toBe(ids.length);
  tests/integration/advanced.test.ts:222 - "should handle rapid sequential requests"
    Line 242: expect(results).toHaveLength(10);
    Line 244: expect(result).toHaveProperty('timezone');
    Line 248: expect(totalTime).toBeLessThan(1000);
  tests/integration/advanced.test.ts:254 - "should handle mixed concurrent and sequential requests"
    Line 282: expect(seq1).toHaveProperty('timezone');
    Line 283: expect(seq2).toHaveProperty('result');
    Line 284: expect(concurrentResults[0]).toHaveProperty('formatted');
    Line 285: expect(concurrentResults[1]).toHaveProperty('hours');
    Line 286: expect(seq3).toHaveProperty('business_days');
  tests/edge-cases/timezone-boundaries.test.ts:77 - "should handle fall back correctly"
    Line 89: expect(beforeDST).toBe(afterDST);
  tests/edge-cases/timezone-boundaries.test.ts:102 - "should handle year transition correctly"
    Line 109: expect(todayResult).toBe(0);
    Line 110: expect(tomorrowResult).toBe(1);
  tests/edge-cases/timezone-boundaries.test.ts:113 - "should handle leap year correctly"
    Line 120: expect(feb29Result).toBe(1);
    Line 121: expect(mar1Result).toBe(2);
  tests/data/holidays.verification.test.ts:115 - "should have ${expected.name} on ${expected.date}"
    Line 127: expect(holiday).toBeDefined();
    Line 130: expect(actualDateStr).toBe(expected.date);
  tests/data/holidays.verification.test.ts:144 - "should have ${expected.name} on ${expected.date}"
    Line 155: expect(holiday).toBeDefined();
    Line 158: expect(actualDateStr).toBe(expected.date);
  tests/data/holidays.verification.test.ts:165 - "should correctly calculate fixed date holidays"
    Line 168: expect(july4?.date.toISOString().split('T')[0]).toBe('2025-07-04');
  tests/data/holidays.verification.test.ts:171 - "should correctly calculate nth weekday holidays"
    Line 174: expect(mlk?.date.toISOString().split('T')[0]).toBe('2025-01-20');
    Line 175: expect(mlk?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.verification.test.ts:178 - "should correctly calculate last weekday holidays"
    Line 181: expect(memorial?.date.toISOString().split('T')[0]).toBe('2025-05-26');
    Line 182: expect(memorial?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.verification.test.ts:185 - "should correctly calculate Easter-based holidays"
    Line 190: expect(goodFriday?.date.toISOString().split('T')[0]).toBe('2025-04-18');
    Line 191: expect(easterMonday?.date.toISOString().split('T')[0]).toBe('2025-04-21');
  tests/data/holidays.verification.test.ts:194 - "should correctly calculate Victoria Day (special rule)"
    Line 197: expect(victoria?.date.toISOString().split('T')[0]).toBe('2025-05-19');
    Line 198: expect(victoria?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.verification.test.ts:203 - "should have consistent holiday counts across years"
    Line 210: expect(Math.abs(holidays2025.length - holidays2026.length)).toBeLessThanOrEqual(1);
  tests/data/holidays.verification.test.ts:214 - "should calculate weekday holidays correctly across years"
    Line 223: expect(mlk2025?.date.getDay()).toBe(1); // Monday
    Line 224: expect(mlk2026?.date.getDay()).toBe(1); // Monday
    Line 225: expect(mlk2025?.date.getDate()).toBeGreaterThanOrEqual(15);
    Line 226: expect(mlk2025?.date.getDate()).toBeLessThanOrEqual(21);
    Line 227: expect(mlk2026?.date.getDate()).toBeGreaterThanOrEqual(15);
    Line 228: expect(mlk2026?.date.getDate()).toBeLessThanOrEqual(21);
  tests/data/holidays.ve-cl.test.ts:32 - "should return correct number of holidays"
    Line 34: expect(result).toHaveLength(12);
  tests/data/holidays.ve-cl.test.ts:38 - "should include ${englishName} on ${date}"
    Line 43: expect(holiday).toBeDefined();
    Line 44: expect(holiday?.date.toISOString().split('T')[0]).toBe(date);
  tests/data/holidays.ve-cl.test.ts:48 - "should calculate Carnival dates based on Easter"
    Line 54: expect(carnivalMonday?.date.toISOString().split('T')[0]).toBe('2025-03-03');
    Line 55: expect(carnivalTuesday?.date.toISOString().split('T')[0]).toBe('2025-03-04');
  tests/data/holidays.ve-cl.test.ts:60 - "should calculate different Carnival dates for 2026"
    Line 66: expect(carnivalMonday?.date.toISOString().split('T')[0]).toBe('2026-02-16');
    Line 67: expect(carnivalTuesday?.date.toISOString().split('T')[0]).toBe('2026-02-17');
  tests/data/holidays.ve-cl.test.ts:72 - "should recognize VE holidays"
    Line 74: expect(isHoliday(new Date(2025, 0, 1), 'VE')).toBe(true); // Jan 1
    Line 75: expect(isHoliday(new Date(2025, 2, 3), 'VE')).toBe(true); // March 3 - Carnival Monday
    Line 76: expect(isHoliday(new Date(2025, 11, 25), 'VE')).toBe(true); // Dec 25
    Line 77: expect(isHoliday(new Date(2025, 0, 2), 'VE')).toBe(false); // Jan 2
  tests/data/holidays.ve-cl.test.ts:125 - "should return correct number of holidays"
    Line 127: expect(result).toHaveLength(16);
  tests/data/holidays.ve-cl.test.ts:131 - "should include ${englishName} on ${date}${originalDate ? "
    Line 139: expect(holiday).toBeDefined();
    Line 140: expect(holiday?.date.toISOString().split('T')[0]).toBe(date);
  tests/data/holidays.ve-cl.test.ts:146 - "should move Sunday holidays to Monday"
    Line 151: expect(sanPedro?.date.toISOString().split('T')[0]).toBe('2025-06-30');
    Line 152: expect(sanPedro?.date.getDay()).toBe(1); // Monday
    Line 156: expect(encuentro?.date.toISOString().split('T')[0]).toBe('2025-10-13');
    Line 157: expect(encuentro?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.ve-cl.test.ts:160 - "should move Tuesday/Wednesday/Thursday holidays to previous Monday"
    Line 165: expect(sanPedro2027?.date.toISOString().split('T')[0]).toBe('2027-06-28'); // Previous Monday
    Line 166: expect(sanPedro2027?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.ve-cl.test.ts:169 - "should move Saturday holidays to Monday"
    Line 174: expect(encuentro2024?.date.toISOString().split('T')[0]).toBe('2024-10-14'); // Next Monday
    Line 175: expect(encuentro2024?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.ve-cl.test.ts:178 - "should not move Friday holidays (already creates long weekend)"
    Line 182: expect(encuentro2029?.date.toISOString().split('T')[0]).toBe('2029-10-12'); // Stays on Friday
    Line 183: expect(encuentro2029?.date.getDay()).toBe(5); // Friday
  tests/data/holidays.ve-cl.test.ts:186 - "should not move Monday holidays"
    Line 190: expect(sanPedro2026?.date.toISOString().split('T')[0]).toBe('2026-06-29'); // Stays on Monday
    Line 191: expect(sanPedro2026?.date.getDay()).toBe(1); // Monday
  tests/data/holidays.ve-cl.test.ts:196 - "should recognize CL holidays including moved ones"
    Line 198: expect(isHoliday(new Date(2025, 0, 1), 'CL')).toBe(true); // Jan 1
    Line 199: expect(isHoliday(new Date(2025, 5, 30), 'CL')).toBe(true); // June 30 - Moved San Pedro
    Line 200: expect(isHoliday(new Date(2025, 5, 29), 'CL')).toBe(false); // June 29 - Original date, not a holiday
    Line 201: expect(isHoliday(new Date(2025, 9, 13), 'CL')).toBe(true); // Oct 13 - Moved Encuentro
    Line 202: expect(isHoliday(new Date(2025, 9, 12), 'CL')).toBe(false); // Oct 12 - Original date, not a holiday
  tests/data/holidays.test.ts:36 - "should return empty array for unknown country"
    Line 38: expect(unknownHolidays).toEqual([]);
  tests/data/holidays.test.ts:43 - "should calculate fixed holiday date for a year"
    Line 53: expect(date).toEqual(new Date(2025, 6, 4)); // July 4, 2025
  tests/data/holidays.test.ts:56 - "should handle leap year for Feb 29"
    Line 66: expect(date2024).toEqual(new Date(2024, 1, 29));
    Line 69: expect(date2025).toBeNull(); // Not a leap year
  tests/data/holidays.test.ts:74 - "should calculate MLK Day (3rd Monday in January)"
    Line 85: expect(date2025).toEqual(new Date(2025, 0, 20)); // January 20, 2025
    Line 88: expect(date2024).toEqual(new Date(2024, 0, 15)); // January 15, 2024
  tests/data/holidays.test.ts:91 - "should calculate Thanksgiving (4th Thursday in November)"
    Line 102: expect(date2025).toEqual(new Date(2025, 10, 27)); // November 27, 2025
  tests/data/holidays.test.ts:105 - "should calculate Memorial Day (last Monday in May)"
    Line 116: expect(date2025).toEqual(new Date(2025, 4, 26)); // May 26, 2025
  tests/data/holidays.test.ts:119 - "should return null for non-existent occurrence"
    Line 130: expect(date).toBeNull();
  tests/data/holidays.test.ts:135 - "should apply US Federal observation rules"
    Line 139: expect(observed).toEqual(new Date(2026, 6, 3)); // Friday
    Line 144: expect(observed2).toEqual(new Date(2027, 6, 5)); // Monday
    Line 149: expect(observed3).toEqual(july4_2025);
  tests/data/holidays.test.ts:152 - "should apply UK Bank holiday rules"
    Line 156: expect(observed).toEqual(new Date(2027, 11, 27)); // Monday
    Line 161: expect(observed2).toEqual(new Date(2027, 11, 27)); // Monday
  tests/data/holidays.test.ts:164 - "should not observe when rule is "
    Line 167: expect(observed).toEqual(saturday);
  tests/data/holidays.test.ts:170 - "should always use actual date when rule is "
    Line 173: expect(observed).toEqual(weekday);
  tests/data/holidays.test.ts:193 - "should include observed dates when different from actual"
    Line 198: expect(july4).toBeDefined();
    Line 199: expect(july4!.date.toISOString().split('T')[0]).toBe('2026-07-04');
    Line 200: expect(july4!.observedDate?.toISOString().split('T')[0]).toBe('2026-07-03');
  tests/data/holidays.test.ts:203 - "should return empty array for unknown country"
    Line 205: expect(holidays).toEqual([]);
  tests/data/holidays.easter.test.ts:7 - "should calculate Easter date for known years"
    Line 21: expect(result).toEqual({ year, month, day });
  tests/data/holidays.easter.test.ts:42 - "should calculate Good Friday (2 days before Easter)"
    Line 52: expect(goodFriday2025).toEqual(new Date(2025, 3, 18)); // month is 0-indexed
    Line 56: expect(goodFriday2024).toEqual(new Date(2024, 2, 29));
  tests/data/holidays.easter.test.ts:59 - "should calculate Easter Monday (1 day after Easter)"
    Line 69: expect(easterMonday2025).toEqual(new Date(2025, 3, 21));
    Line 73: expect(easterMonday2024).toEqual(new Date(2024, 3, 1));
  tests/data/holidays.easter.test.ts:76 - "should calculate Easter Sunday (offset 0)"
    Line 85: expect(easterSunday2025).toEqual(new Date(2025, 3, 20));
  tests/data/holidays.easter.test.ts:88 - "should calculate Easter Saturday (1 day before Easter)"
    Line 97: expect(easterSaturday2025).toEqual(new Date(2025, 3, 19));
  tests/data/holidays.easter.test.ts:100 - "should handle holidays with no offset (default to 0)"
    Line 108: expect(easter2025).toEqual(new Date(2025, 3, 20));
  tests/data/holidays.easter.test.ts:111 - "should handle large offsets for other Easter-based holidays"
    Line 121: expect(ascension2025).toEqual(new Date(2025, 4, 29)); // May 29
    Line 132: expect(pentecost2025).toEqual(new Date(2025, 5, 8)); // June 8
  tests/data/holidays.easter.test.ts:139 - "should include Easter-based holidays for UK"
    Line 146: expect(goodFriday?.date).toEqual(new Date(2025, 3, 18));
    Line 147: expect(easterMonday?.date).toEqual(new Date(2025, 3, 21));
  tests/data/holidays.easter.test.ts:150 - "should include Easter-based holidays for AU"
    Line 158: expect(goodFriday?.date).toEqual(new Date(2025, 3, 18));
    Line 159: expect(easterSaturday?.date).toEqual(new Date(2025, 3, 19));
    Line 160: expect(easterMonday?.date).toEqual(new Date(2025, 3, 21));
  tests/data/holidays.easter.test.ts:163 - "should include Good Friday for CA"
    Line 168: expect(goodFriday?.date).toEqual(new Date(2025, 3, 18));
  tests/data/holidays.ca-au.test.ts:13 - "should have New Year"
    Line 14: expect(holidayMap.has('2025-01-01')).toBe(true);
    Line 15: expect(holidayMap.get('2025-01-01')?.name).toBe("New Year's Day");
  tests/data/holidays.ca-au.test.ts:18 - "should have Canada Day on July 1"
    Line 19: expect(holidayMap.has('2025-07-01')).toBe(true);
    Line 20: expect(holidayMap.get('2025-07-01')?.name).toBe('Canada Day');
  tests/data/holidays.ca-au.test.ts:23 - "should have Victoria Day on Monday before May 25"
    Line 24: expect(holidayMap.has('2025-05-19')).toBe(true);
    Line 25: expect(holidayMap.get('2025-05-19')?.name).toBe('Victoria Day');
  tests/data/holidays.ca-au.test.ts:28 - "should have Labour Day on first Monday in September"
    Line 29: expect(holidayMap.has('2025-09-01')).toBe(true);
    Line 30: expect(holidayMap.get('2025-09-01')?.name).toBe('Labour Day');
  tests/data/holidays.ca-au.test.ts:33 - "should have Thanksgiving on second Monday in October"
    Line 34: expect(holidayMap.has('2025-10-13')).toBe(true);
    Line 35: expect(holidayMap.get('2025-10-13')?.name).toBe('Thanksgiving Day');
  tests/data/holidays.ca-au.test.ts:38 - "should have Christmas Day"
    Line 39: expect(holidayMap.has('2025-12-25')).toBe(true);
    Line 40: expect(holidayMap.get('2025-12-25')?.name).toBe('Christmas Day');
  tests/data/holidays.ca-au.test.ts:43 - "should have Boxing Day"
    Line 44: expect(holidayMap.has('2025-12-26')).toBe(true);
    Line 45: expect(holidayMap.get('2025-12-26')?.name).toBe('Boxing Day');
  tests/data/holidays.ca-au.test.ts:48 - "should have Remembrance Day"
    Line 49: expect(holidayMap.has('2025-11-11')).toBe(true);
    Line 50: expect(holidayMap.get('2025-11-11')?.name).toBe('Remembrance Day');
  tests/data/holidays.ca-au.test.ts:55 - "should calculate Victoria Day correctly for multiple years"
    Line 67: expect(victoriaDay).toBeDefined();
    Line 68: expect(victoriaDay!.date.toISOString().split('T')[0]).toBe(expected);
  tests/data/holidays.ca-au.test.ts:74 - "should observe Canada Day on Monday when it falls on Sunday"
    Line 78: expect(canadaDay?.date.toISOString().split('T')[0]).toBe('2029-07-01');
    Line 79: expect(canadaDay?.observedDate?.toISOString().split('T')[0]).toBe('2029-07-02');
  tests/data/holidays.ca-au.test.ts:84 - "should identify Canadian holidays"
    Line 85: expect(isHoliday(new Date(2025, 6, 1), 'CA')).toBe(true); // July is month 6
    Line 86: expect(isHoliday(new Date(2025, 6, 2), 'CA')).toBe(false);
    Line 88: expect(isHoliday(new Date(2029, 6, 2), 'CA', { checkObserved: true })).toBe(true); // Canada Day observed
  tests/data/holidays.ca-au.test.ts:103 - "should have New Year"
    Line 104: expect(holidayMap.has('2025-01-01')).toBe(true);
    Line 105: expect(holidayMap.get('2025-01-01')?.name).toBe("New Year's Day");
  tests/data/holidays.ca-au.test.ts:108 - "should have Australia Day on January 26"
    Line 109: expect(holidayMap.has('2025-01-26')).toBe(true);
    Line 110: expect(holidayMap.get('2025-01-26')?.name).toBe('Australia Day');
  tests/data/holidays.ca-au.test.ts:113 - "should have Anzac Day on April 25"
    Line 114: expect(holidayMap.has('2025-04-25')).toBe(true);
    Line 115: expect(holidayMap.get('2025-04-25')?.name).toBe('Anzac Day');
  tests/data/holidays.ca-au.test.ts:118 - "should have Queen"
    Line 119: expect(holidayMap.has('2025-06-09')).toBe(true);
    Line 120: expect(holidayMap.get('2025-06-09')?.name).toBe("Queen's Birthday");
  tests/data/holidays.ca-au.test.ts:123 - "should have Christmas Day"
    Line 124: expect(holidayMap.has('2025-12-25')).toBe(true);
    Line 125: expect(holidayMap.get('2025-12-25')?.name).toBe('Christmas Day');
  tests/data/holidays.ca-au.test.ts:128 - "should have Boxing Day"
    Line 129: expect(holidayMap.has('2025-12-26')).toBe(true);
    Line 130: expect(holidayMap.get('2025-12-26')?.name).toBe('Boxing Day');
  tests/data/holidays.ca-au.test.ts:135 - "should observe Australia Day on Monday when it falls on Sunday"
    Line 139: expect(australiaDay?.date.toISOString().split('T')[0]).toBe('2025-01-26');
    Line 140: expect(australiaDay?.observedDate?.toISOString().split('T')[0]).toBe('2025-01-27');
  tests/data/holidays.ca-au.test.ts:143 - "should NOT observe on Monday when holiday falls on Saturday"
    Line 148: expect(anzacDay?.date.toISOString().split('T')[0]).toBe('2026-04-25');
    Line 149: expect(anzacDay?.observedDate).toBeUndefined(); // No Monday observation
  tests/data/holidays.ca-au.test.ts:154 - "should identify Australian holidays"
    Line 155: expect(isHoliday(new Date(2025, 0, 26), 'AU')).toBe(true); // January is month 0
    Line 156: expect(isHoliday(new Date(2025, 0, 27), 'AU')).toBe(false); // Not the actual date
    Line 158: expect(isHoliday(new Date(2025, 0, 27), 'AU', { checkObserved: true })).toBe(true); // Australia Day observed
  tests/data/holidays-refactor.test.ts:6 - "should handle Victoria Day special case"
    Line 25: expect(result).toEqual(expected);
  tests/data/holidays-refactor.test.ts:29 - "should handle last occurrence correctly"
    Line 40: expect(result).toEqual(new Date(2025, 4, 26)); // Last Monday in May
  tests/data/holidays-refactor.test.ts:43 - "should handle nth occurrence that exceeds month"
    Line 54: expect(result).toBeNull();
  tests/data/holidays-refactor.test.ts:57 - "should return null for invalid holiday type"
    Line 68: expect(result).toBeNull();
  tests/cache/memoryAwareCache.test.ts:19 - "should create cache with default 10MB limit"
    Line 21: expect(defaultCache.getMemoryStats().maxMemory).toBe(10 * 1024 * 1024);
  tests/cache/memoryAwareCache.test.ts:24 - "should accept custom memory limit"
    Line 25: expect(cache.getMemoryStats().maxMemory).toBe(1024);
  tests/cache/memoryAwareCache.test.ts:42 - "should calculate object size consistently"
    Line 53: expect(size2).toBe(size1);
  tests/cache/memoryAwareCache.test.ts:56 - "should reduce memory usage when deleting entries"
    Line 59: expect(afterAdd).toBeGreaterThan(0);
    Line 64: expect(afterDel).toBe(0);
  tests/cache/memoryAwareCache.test.ts:69 - "should reject set when memory limit would be exceeded"
    Line 76: expect(result).toBe(false);
    Line 77: expect(cache.has('overflow')).toBe(false);
    Line 78: expect(cache.has('big')).toBe(true);
  tests/cache/memoryAwareCache.test.ts:81 - "should emit memory warning at 90% usage"
    Line 83: expect(stats.usedMemory / stats.maxMemory).toBeGreaterThanOrEqual(0.9);
  tests/cache/memoryAwareCache.test.ts:91 - "should evict oldest entries when eviction enabled"
    Line 105: expect(evictCache.has('old1')).toBe(false);
    Line 106: expect(evictCache.has('new')).toBe(true);
  tests/cache/memoryAwareCache.test.ts:112 - "should return accurate memory statistics"
    Line 118: expect(stats).toMatchObject({
    Line 126: expect(stats.usedMemory + stats.availableMemory).toBe(stats.maxMemory);
  tests/cache/memoryAwareCache.test.ts:142 - "should handle various data types"
    Line 156: expect(memory).toBeGreaterThan(0);
    Line 157: expect(memory).toBeLessThan(1024); // Should fit in our 1KB cache
  tests/cache/memoryAwareCache.test.ts:161 - "should account for key size in memory calculation"
    Line 174: expect(longKeyMemory).toBeGreaterThan(shortKeyMemory);
  tests/tools/recurrence/YearlyRecurrence.test.ts:10 - "should calculate next year for regular date"
    Line 18: expect(result).toEqual(new Date('2025-06-15T10:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:21 - "should handle leap year Feb 29"
    Line 30: expect(result).toEqual(new Date('2025-02-28T10:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:33 - "should preserve exact time"
    Line 41: expect(result).toEqual(new Date('2025-06-15T14:30:45.123Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:44 - "should handle year-end dates"
    Line 52: expect(result).toEqual(new Date('2025-12-31T23:59:59Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:57 - "should find next occurrence of specific date in future"
    Line 68: expect(result).toEqual(new Date('2024-12-25T00:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:71 - "should advance to next year if date has passed"
    Line 82: expect(result).toEqual(new Date('2025-01-01T00:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:85 - "should handle Feb 29 in specific date mode"
    Line 96: expect(result).toEqual(new Date('2025-02-28T00:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:99 - "should handle current day being target day"
    Line 110: expect(result).toEqual(new Date('2025-12-25T00:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:115 - "should set specific time for same-date pattern"
    Line 124: expect(result).toEqual(new Date('2025-06-15T14:30:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:127 - "should set specific time for specific-date pattern"
    Line 138: expect(result).toEqual(new Date('2024-12-25T08:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:141 - "should check time when on same day"
    Line 153: expect(result).toEqual(new Date('2025-12-25T14:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:158 - "should calculate in specified timezone for same-date pattern"
    Line 169: expect(result).toEqual(new Date('2025-06-15T14:00:00Z')); // 10am EDT
  tests/tools/recurrence/YearlyRecurrence.test.ts:172 - "should handle DST transitions"
    Line 184: expect(result).toEqual(new Date('2025-03-10T18:00:00Z')); // 2pm EDT
  tests/tools/recurrence/YearlyRecurrence.test.ts:187 - "should find specific date in timezone"
    Line 200: expect(result).toEqual(new Date('2024-12-30T13:00:00Z')); // Dec 31 midnight Sydney
  tests/tools/recurrence/YearlyRecurrence.test.ts:205 - "should handle leap year to leap year"
    Line 218: expect(result).toEqual(new Date('2028-02-28T10:00:00Z'));
  tests/tools/recurrence/YearlyRecurrence.test.ts:221 - "should handle month-end dates"
    Line 232: expect(result).toEqual(new Date('2024-02-29T00:00:00Z')); // 2024 is leap year
  tests/tools/recurrence/YearlyRecurrence.test.ts:235 - "should handle -1 for last day of month"
    Line 246: expect(result).toEqual(new Date('2025-02-28T00:00:00Z'));
  tests/tools/recurrence/WeeklyRecurrence.test.ts:17 - "should return next week same day when no day specified"
    Line 28: expect(result.toISOString()).toBe('2025-01-22T10:30:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:31 - "should return next occurrence of specified weekday"
    Line 43: expect(result.toISOString()).toBe('2025-01-17T10:30:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:46 - "should handle Sunday (0) correctly"
    Line 57: expect(result.toISOString()).toBe('2025-01-19T10:30:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:60 - "should handle Saturday (6) correctly"
    Line 71: expect(result.toISOString()).toBe('2025-01-18T10:30:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:74 - "should return today if same weekday and time has not passed"
    Line 86: expect(result.toISOString()).toBe('2025-01-15T14:30:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:89 - "should return next week if same weekday but time has passed"
    Line 101: expect(result.toISOString()).toBe('2025-01-22T09:00:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:104 - "should handle timezone correctly"
    Line 116: expect(result.toISOString()).toBe('2025-01-17T14:00:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:119 - "should handle timezone when calculating day of week"
    Line 135: expect(result.toISOString()).toBe('2025-01-15T03:00:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:138 - "should handle wrapping around to next week"
    Line 149: expect(result.toISOString()).toBe('2025-01-20T10:30:00.000Z');
  tests/tools/recurrence/WeeklyRecurrence.test.ts:152 - "should preserve seconds and milliseconds as 0 with time"
    Line 163: expect(result.getSeconds()).toBe(0);
    Line 164: expect(result.getMilliseconds()).toBe(0);
  tests/tools/recurrence/WeeklyRecurrence.test.ts:167 - "should handle same day without specific time"
    Line 178: expect(result.toISOString()).toBe('2025-01-22T10:30:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:9 - "should set time in UTC when timezone is UTC"
    Line 14: expect(result.toISOString()).toBe('2025-01-15T14:30:00.000Z');
    Line 15: expect(result.getUTCHours()).toBe(14);
    Line 16: expect(result.getUTCMinutes()).toBe(30);
    Line 17: expect(result.getUTCSeconds()).toBe(0);
    Line 18: expect(result.getUTCMilliseconds()).toBe(0);
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:21 - "should set time in UTC when timezone is empty string"
    Line 26: expect(result.toISOString()).toBe('2025-01-15T09:15:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:29 - "should set time in specified timezone"
    Line 36: expect(result.toISOString()).toBe('2025-01-15T19:30:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:39 - "should handle different timezone conversions"
    Line 46: expect(tokyoResult.toISOString()).toBe('2025-01-15T05:30:00.000Z');
    Line 51: expect(londonResult.toISOString()).toBe('2025-01-15T14:30:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:54 - "should preserve the date when setting time"
    Line 61: expect(result.toISOString()).toBe('2025-01-20T06:00:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:64 - "should handle midnight correctly"
    Line 69: expect(result.toISOString()).toBe('2025-01-15T00:00:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:72 - "should handle end of day correctly"
    Line 77: expect(result.toISOString()).toBe('2025-01-15T23:59:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:82 - "should add days preserving time in UTC"
    Line 87: expect(result.toISOString()).toBe('2025-01-18T14:30:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:90 - "should add days preserving time in timezone"
    Line 97: expect(result.toISOString()).toBe('2025-01-16T14:00:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:100 - "should handle DST transitions when adding days"
    Line 108: expect(result.toISOString()).toBe('2025-03-10T13:00:00.000Z');
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:113 - "should return true when time is in future"
    Line 119: expect(result).toBe(true);
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:122 - "should return false when time is in past"
    Line 128: expect(result).toBe(false);
  tests/tools/recurrence/TimezoneDateBuilder.test.ts:131 - "should return false when times are equal"
    Line 137: expect(result).toBe(false);
  tests/tools/recurrence/RecurrenceFactory.test.ts:21 - "should create DailyRecurrence for daily pattern"
    Line 24: expect(recurrence).toBeInstanceOf(DailyRecurrence);
  tests/tools/recurrence/RecurrenceFactory.test.ts:27 - "should create WeeklyRecurrence for weekly pattern"
    Line 30: expect(recurrence).toBeInstanceOf(WeeklyRecurrence);
  tests/tools/recurrence/RecurrenceFactory.test.ts:33 - "should create MonthlyRecurrence for monthly pattern"
    Line 36: expect(recurrence).toBeInstanceOf(MonthlyRecurrence);
  tests/tools/recurrence/RecurrenceFactory.test.ts:39 - "should create YearlyRecurrence for yearly pattern"
    Line 42: expect(recurrence).toBeInstanceOf(YearlyRecurrence);
  tests/tools/recurrence/RecurrenceFactory.test.ts:47 - "should validate params before creating instance"
    Line 53: expect(validatorSpy).toHaveBeenCalledWith(params);
  tests/tools/recurrence/RecurrenceFactory.test.ts:89 - "should validate and calculate in one step"
    Line 95: expect(result).toEqual(new Date('2024-01-16T10:00:00Z'));
  tests/tools/recurrence/RecurrenceFactory.test.ts:98 - "should handle weekly calculation"
    Line 104: expect(result).toEqual(new Date('2024-01-17T10:00:00Z'));
  tests/tools/recurrence/RecurrenceFactory.test.ts:107 - "should handle monthly calculation"
    Line 113: expect(result).toEqual(new Date('2024-01-20T00:00:00Z'));
  tests/tools/recurrence/RecurrenceFactory.test.ts:116 - "should handle yearly calculation"
    Line 122: expect(result).toEqual(new Date('2025-06-15T10:00:00Z'));
  tests/tools/recurrence/RecurrenceFactory.test.ts:143 - "should pass timezone to recurrence instance"
    Line 154: expect(result).toEqual(new Date('2024-01-15T19:30:00Z')); // 14:30 EST = 19:30 UTC
  tests/tools/recurrence/RecurrenceFactory.test.ts:157 - "should handle UTC timezone (empty string)"
    Line 168: expect(result).toEqual(new Date('2024-01-15T14:30:00Z'));
  tests/tools/recurrence/RecurrenceFactory.test.ts:171 - "should use system timezone when undefined"
    Line 181: expect(result).toEqual(new Date('2024-01-16T10:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:10 - "should calculate next month for mid-month dates"
    Line 19: expect(result).toEqual(new Date('2024-02-15T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:22 - "should handle month-end overflow (31st to Feb)"
    Line 32: expect(result).toEqual(new Date('2024-02-29T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:35 - "should handle month-end overflow (31st to April)"
    Line 45: expect(result).toEqual(new Date('2024-04-30T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:48 - "should handle non-leap year February"
    Line 58: expect(result).toEqual(new Date('2025-02-28T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:63 - "should set specific time on target day"
    Line 73: expect(result).toEqual(new Date('2024-01-20T14:30:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:76 - "should advance to next month if target datetime has passed"
    Line 86: expect(result).toEqual(new Date('2024-02-20T14:30:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:91 - "should calculate in specified timezone"
    Line 104: expect(result).toEqual(new Date('2024-01-20T19:30:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:107 - "should handle DST transitions correctly"
    Line 120: expect(result).toEqual(new Date('2024-03-15T18:30:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:123 - "should handle month-end in timezone context"
    Line 135: expect(result).toEqual(new Date('2024-02-28T13:00:00Z')); // Feb 29, midnight Sydney
  tests/tools/recurrence/MonthlyRecurrence.test.ts:140 - "should handle current day being target day"
    Line 150: expect(result).toEqual(new Date('2024-02-15T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:153 - "should handle last day of month request"
    Line 162: expect(result).toEqual(new Date('2024-01-31T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:165 - "should handle year boundary"
    Line 174: expect(result).toEqual(new Date('2024-12-20T00:00:00Z'));
  tests/tools/recurrence/MonthlyRecurrence.test.ts:177 - "should advance to next year if needed"
    Line 186: expect(result).toEqual(new Date('2025-01-20T00:00:00Z'));
  tests/tools/recurrence/DailyRecurrence.test.ts:17 - "should return next day at same time when no specific time given"
    Line 23: expect(result.toISOString()).toBe('2025-01-16T10:30:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:26 - "should return today at specified time if time has not passed"
    Line 36: expect(result.toISOString()).toBe('2025-01-15T14:30:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:39 - "should return tomorrow at specified time if time has passed"
    Line 49: expect(result.toISOString()).toBe('2025-01-16T09:00:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:52 - "should handle timezone correctly when calculating next occurrence"
    Line 63: expect(result.toISOString()).toBe('2025-01-15T19:30:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:66 - "should handle timezone when time has passed"
    Line 77: expect(result.toISOString()).toBe('2025-01-16T14:00:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:80 - "should work with empty string as UTC timezone"
    Line 90: expect(result.toISOString()).toBe('2025-01-15T14:00:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:93 - "should handle exact same time as current (edge case)"
    Line 104: expect(result.toISOString()).toBe('2025-01-16T10:30:00.000Z');
  tests/tools/recurrence/DailyRecurrence.test.ts:107 - "should preserve seconds and milliseconds as 0"
    Line 117: expect(result.toISOString()).toBe('2025-01-15T14:30:00.000Z');
    Line 118: expect(result.getSeconds()).toBe(0);
    Line 119: expect(result.getMilliseconds()).toBe(0);
  tests/integration/tools/daysUntil.integration.test.ts:6 - "should calculate days until a future date"
    Line 17: expect(result).toBe(7);
  tests/integration/tools/daysUntil.integration.test.ts:23 - "should return 0 for today"
    Line 33: expect(result).toBe(0);
  tests/integration/tools/daysUntil.integration.test.ts:39 - "should return negative days for past dates"
    Line 50: expect(result).toBe(-5);
  tests/integration/tools/daysUntil.integration.test.ts:56 - "should format as "
    Line 67: expect(result).toBe('Today');
  tests/integration/tools/daysUntil.integration.test.ts:73 - "should format as "
    Line 85: expect(result).toBe('Tomorrow');
  tests/integration/tools/daysUntil.integration.test.ts:91 - "should format as "
    Line 103: expect(result).toBe('in 10 days');
  tests/integration/tools/daysUntil.integration.test.ts:109 - "should handle specific timezone"
    Line 120: expect(result).toBeGreaterThan(0);
    Line 121: expect(result).toBeLessThan(365);
  tests/integration/tools/daysUntil.integration.test.ts:127 - "should use UTC when timezone is empty string"
    Line 139: expect(result).toBe(1);
  tests/integration/tools/daysUntil.integration.test.ts:193 - "should handle Christmas countdown"
    Line 202: expect(result).toBeGreaterThan(0);
    Line 203: expect(result).toBeLessThan(365);
  tests/integration/tools/daysUntil.integration.test.ts:209 - "should handle event planning with formatted output"
    Line 221: expect(result).toBe('in 30 days');
  tests/adapters/mcp-sdk/mapper.test.ts:75 - "should return McpError unchanged if already McpError"
    Line 79: expect(mcpError).toBe(originalError);
  tests/adapters/mcp-sdk/mapper-edge-cases.test.ts:111 - "should handle Promise rejection values"
    Line 118: expect(mcpError).toBeInstanceOf(McpError);
  tests/adapters/mcp-sdk/errors.test.ts:141 - "should all extend BaseError"
    Line 152: expect(error).toBeInstanceOf(BaseError);
    Line 153: expect(error).toBeInstanceOf(Error);

🔍 SUSPICIOUS TESTS:
  tests/index.test.ts:41 - "should create server with correct info"
    - All assertions are trivial or meaningless
  tests/index.test.ts:46 - "should register tool handlers"
    - Line 57: Suspicious pattern: expect(true).toBe(true);
    - All assertions are trivial or meaningless
  tests/index.test.ts:223 - "should return correct tool names"
    - All assertions are trivial or meaningless
  tests/index.test.ts:560 - "should read configuration from environment variables"
    - All assertions are trivial or meaningless
  tests/index.rateLimit.test.ts:250 - "should create rate limiter with environment configuration"
    - All assertions are trivial or meaningless
  tests/utils/withDebug.test.ts:33 - "logs function entry with arguments"
    - All assertions are trivial or meaningless
  tests/utils/withDebug.test.ts:43 - "logs successful completion"
    - All assertions are trivial or meaningless
  tests/utils/withDebug.test.ts:65 - "handles async functions that succeed"
    - All assertions are trivial or meaningless
    - Test name suggests async but no async assertions found
  tests/utils/withDebug.test.ts:109 - "handles functions with no name"
    - All assertions are trivial or meaningless
  tests/utils/withDebug.test.ts:117 - "handles error that is a Promise (edge case)"
    - All assertions are trivial or meaningless
    - Test name suggests error handling but no error assertions found
  ... and 605 more

📋 RECOMMENDATIONS:
2. Replace trivial assertions with meaningful ones that test actual behavior
3. Ensure async tests properly await their assertions
4. Tests for error cases should include error assertions (toThrow, rejects)
5. Consider using expect.assertions(n) to ensure expected number of assertions
